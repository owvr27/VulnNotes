# README — شرح مبسّط وواضح عن **SQL Injection (حقن SQL)**



---

## ⚠️ تحذير وأخلاقيات

هذا المحتوى مخصّص **للتعلّم الأخلاقي والبحث الأمني** فقط. لا تُجرب أي تقنيات على أنظمة حقيقية إلا بعد الحصول على إذن صريح. أي استخدام ضار يقع على عاتقك.

---

# ما هو SQL Injection؟

**SQL Injection** أو "حقن SQL" هجوم بيستغل ضعف في طريقة تعامل التطبيق مع مدخلات المستخدم، بحيث تُدخل هذه المدخلات بشكل مباشر داخل استعلام SQL وتغيّر سلوكه. نتيجة ذلك ممكن تكون تسريب بيانات، حذفها، تعديلها، أو حتى تنفيذ أوامر على قاعدة البيانات.

---

# الأنواع الأساسية



## 1) In-band SQLi

المهاجم يحصل على البيانات عبر نفس channel التي استخدمها لإرسال الحمولة.

### • Union-based

**فكرة:** استخدام `UNION` لجلب نتائج إضافية من جدول آخر وضمها لنتيجة الاستعلام الأصلي.

**مثال (payload):**

```sql
' UNION SELECT username, password FROM users -- 
```

**ببساطة:** تضيف نتائج جدول آخر إلى ناتج الاستعلام وتعرض بيانات جديدة.

### • Error-based

**فكرة:** إجبار قاعدة البيانات على خلق خطأ يكشف معلومات مفيدة من رسالة الخطأ.

**مثال (payload):**

```sql
' OR (SELECT 1/0) -- 
```

**ببساطة:** تستغل رسائل الخطأ لمعرفة بنية أو أسماء جداول/أعمدة.

---

## 2) Blind SQLi — الحقن العمياء

هنا قاعدة البيانات لا ترجع بيانات مباشرة. المهاجم يستنتج المعلومات من سلوك التطبيق — هل الشرط صحيح أم خطأ؟ أو من زمن الاستجابة.

### • Boolean-based (Content-based)

**فكرة:** تجرّب شروطًا تعطي true/false لمعرفة بتات من البيانات.

**مثال:**

```sql
' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE id=1) = 'a' -- 
```

**ببساطة:** لو التطبيق رد بطريقة معينة، نعرف إن الحرف الأول من كلمة المرور هو 'a'.

### • Time-based

**فكرة:** تستخدم تأخير (مثلاً `SLEEP`) لتحديد صحة شرط عبر مراقبة وقت الاستجابة.

**مثال:**

```sql
' IF((SELECT SUBSTRING(password,1,1) FROM users WHERE id=1)='a', SLEEP(5), 0) -- 
```

**ببساطة:** لو الطلب اتأخر — يبقى الشرط صحيح.

---

## 3) Out-of-band (OOB) SQLi — الحقن خارج القناة

**فكرة:** عندما لا تنفع القناة العادية، يُطلب من قاعدة البيانات التواصل خارجيًا (DNS/HTTP) إلى خادم يتحكم فيه المهاجم لنقل البيانات.

**ببساطة:** طريقة بديلة لإخراج المعلومات عبر قناة ثانية (مثل طلب DNS) بدلًا من صفحة الويب.

---

# مثال بسيط لصفحة PHP غير مؤمّنة (تعليمي فقط)

```php
<?php
// vulnerable.php — مثال توضيحي
$id = $_GET['id']; // غير معقم
$query = "SELECT * FROM products WHERE id = '$id'";
$result = mysqli_query($conn, $query);
?>
```

**هجوم بسيط:** `vulnerable.php?id=1' OR '1'='1`
سيصبح الاستعلام: `SELECT * FROM products WHERE id = '1' OR '1'='1'` — ما يؤدي لإرجاع كل الصفوف.

---

# كيف تمنع حقن SQL — خطوات عملية ومباشرة

1. **الاستعلامات المحضّرة (Prepared Statements / Parameterized Queries):** أهم وأقوى وسيلة. تمنع تركيب المدخلات داخل الاستعلام.

   **مثال PHP (mysqli - Prepared Statement):**

   ```php
   $stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
   $stmt->bind_param("i", $id);
   $stmt->execute();
   ```

   **مثال Python (psycopg2 - PostgreSQL):**

   ```python
   cur.execute("SELECT * FROM users WHERE id = %s", (user_id,))
   ```

2. **التحقق من المدخلات (Validation):** تأكد من نوع وطول القيم قبل استخدامها (مثلاً: id يجب أن يكون عددًا). لكن التحقق وحده لا يكفي.

3. **استخدم ORM أو مكتبات توفر حماية تلقائية** بدلًا من تركيب SQL يدويًا إن أمكن.

4. **مبدأ أقل الصلاحيات (Least Privilege):** حساب قاعدة البيانات المستخدم من التطبيق لا يحتاج أن يكون مالك الجداول — أعطه صلاحيات محدودة.

5. **إخفاء رسائل الخطأ التفصيلية عن المستخدم النهائي.** احتفظ بسجلات داخلية فقط.

6. **طبقات دفاع إضافية:** جدران تطبيقات الويب (WAF)، أنظمة كشف التسلل، مراقبة السجّلات.

7. **اختبار دوري:** استخدم أدوات فحص أمني (SAST/DAST) وبيئات اختبار مشتركة.

---

